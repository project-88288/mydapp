/**
* This file was automatically generated by @octalmage/terra-cosmwasm-typescript-gen@0.2.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @octalmage/terra-cosmwasm-typescript-gen generate command to regenerate this file.
*/

import { LCDClient, Coins, Wallet, MsgExecuteContract, TxInfo, WaitTxBroadcastResult } from "@terra-money/terra.js";
import { ConnectedWallet } from "@terra-money/wallet-provider";
function isConnectedWallet(x: Wallet | ConnectedWallet): x is ConnectedWallet {
  return typeof (x as Wallet).key === "undefined";
};
async function waitForInclusionInBlock(lcd: LCDClient, txHash: string): Promise<TxInfo | undefined> {
  let res;
  for (let i = 0; i <= 50; i++) {
    try {
      res = await lcd.tx.txInfo(txHash);
    } catch (error) {
      // NOOP
    }
      
    if (res) {
      break;
    }
      
    await new Promise((resolve) => setTimeout(resolve, 500));
  }
      
  return res;
};
export interface CountResponse {
  count: number;
  [k: string]: unknown;
}
export type ExecuteMsg = {
  increment: {
    [k: string]: unknown;
  };
} | {
  reset: {
    count: number;
    [k: string]: unknown;
  };
};
export interface InstantiateMsg {
  count: number;
  [k: string]: unknown;
}
export type QueryMsg = {
  get_count: {
    [k: string]: unknown;
  };
};
export type Addr = string;
export interface State {
  count: number;
  owner: Addr;
  [k: string]: unknown;
}
export interface MydappReadOnlyInterface {
  contractAddress: string;
  getCountQuery: () => Promise<CountResponse>;
}
export class MydappQueryClient implements MydappReadOnlyInterface {
  client: LCDClient;
  contractAddress: string;

  constructor(client: LCDClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getCountQuery = this.getCountQuery.bind(this);
  }

  getCountQuery = async (): Promise<CountResponse> => {
    return this.client.wasm.contractQuery(this.contractAddress, {
      get_count: {}
    });
  };
}
export interface MydappInterface extends MydappReadOnlyInterface {
  contractAddress: string;
  increment: (funds?: Coins) => Promise<any>;
  reset: ({
    count
  }: {
    count: number;
  }, funds?: Coins) => Promise<any>;
}
export class MydappClient extends MydappQueryClient implements MydappInterface {
  client: LCDClient;
  wallet: Wallet | ConnectedWallet;
  contractAddress: string;

  constructor(client: LCDClient, wallet: Wallet | ConnectedWallet, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.wallet = wallet;
    this.contractAddress = contractAddress;
    this.increment = this.increment.bind(this);
    this.reset = this.reset.bind(this);
  }

  increment = async (funds?: Coins): Promise<WaitTxBroadcastResult | TxInfo | undefined> => {
    const senderAddress = isConnectedWallet(this.wallet) ? this.wallet.walletAddress : this.wallet.key.accAddress;
    const execMsg = new MsgExecuteContract(senderAddress, this.contractAddress, {
      increment: {}
    }, funds);

    if (isConnectedWallet(this.wallet)) {
      const tx = await this.wallet.post({
        msgs: [execMsg]
      });
      return waitForInclusionInBlock(this.client, tx.result.txhash);
    } else {
      const execTx = await this.wallet.createAndSignTx({
        msgs: [execMsg]
      });
      return this.client.tx.broadcast(execTx);
    }
  };
  reset = async ({
    count
  }: {
    count: number;
  }, funds?: Coins): Promise<WaitTxBroadcastResult | TxInfo | undefined> => {
    const senderAddress = isConnectedWallet(this.wallet) ? this.wallet.walletAddress : this.wallet.key.accAddress;
    const execMsg = new MsgExecuteContract(senderAddress, this.contractAddress, {
      reset: {
        count
      }
    }, funds);

    if (isConnectedWallet(this.wallet)) {
      const tx = await this.wallet.post({
        msgs: [execMsg]
      });
      return waitForInclusionInBlock(this.client, tx.result.txhash);
    } else {
      const execTx = await this.wallet.createAndSignTx({
        msgs: [execMsg]
      });
      return this.client.tx.broadcast(execTx);
    }
  };
}